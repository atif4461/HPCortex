#include<HPCortex.hpp>
#include<Testing.hpp>

//Compute outer product of incoming derivative from above and the derivative of the activation function
//out(i, b) = above_deriv(i,b) * activation_deriv(i,b)
/**
 * @brief Computes the thin matrix outer product base by element-wise multiplication of two matrices.
 *
 * This function takes two input matrices representing derivatives and computes their element-wise product,
 * resulting in a new matrix where each element is the product of corresponding elements from the inputs.
 *
 * @param[in] above_deriv The first input matrix containing derivative values.
 * @param[in] activation_deriv The second input matrix containing derivative values.
 *
 * @return A new matrix containing the element-wise product of the input matrices.
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
template<typename FloatType>
Matrix<FloatType> computeThinMatOuterProdBase(const Matrix<FloatType> &above_deriv, const Matrix<FloatType> &activation_deriv){
  int size0 = above_deriv.size(0);
  int batch_size =  above_deriv.size(1);
  assert(activation_deriv.size(0) == size0 && activation_deriv.size(1) == batch_size);
  
  Matrix<FloatType> activated_above_deriv(size0,batch_size);
  autoView(above_deriv_v,above_deriv,DeviceRead);
  autoView(activation_deriv_v,activation_deriv,DeviceRead);
  autoView(activated_above_deriv_v,activated_above_deriv,DeviceWrite);
 
  accelerator_for3d(dummy,1,b,batch_size,i,size0,32,{
      activated_above_deriv_v(i,b) = above_deriv_v(i,b) * activation_deriv_v(i,b);
    });
  return activated_above_deriv;
}

/**
 * @brief Computes the thin matrix outer product of two matrices.
 *
 * This function takes two input matrices, above_deriv and activation_deriv,
 * and returns their element-wise product as a new matrix.
 *
 * The computation is performed in parallel across batches using an accelerator.
 *
 * @param[in] above_deriv Input matrix representing derivatives from above.
 * @param[in] activation_deriv Input matrix representing activation derivatives.
 * @return Resulting matrix containing the element-wise product of inputs.
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
template<typename FloatType>
Matrix<FloatType> computeThinMatOuterProd_v2(const Matrix<FloatType> &above_deriv, const Matrix<FloatType> &activation_deriv){
  int size0 = above_deriv.size(0);
  int batch_size =  above_deriv.size(1);
  assert(activation_deriv.size(0) == size0 && activation_deriv.size(1) == batch_size);
  
  Matrix<FloatType> activated_above_deriv(size0,batch_size);
  autoView(above_deriv_v,above_deriv,DeviceRead);
  autoView(activation_deriv_v,activation_deriv,DeviceRead);
  autoView(activated_above_deriv_v,activated_above_deriv,DeviceWrite);

  int bblocksize = std::min(128,batch_size);
  int nbblocks = (batch_size + bblocksize - 1) / bblocksize; 
  
  accelerator_for3d(bb,bblocksize,bblock,nbblocks,i,size0,1,{      
      int b = bb + bblocksize*bblock;
      if(b < batch_size){      
	activated_above_deriv_v(i,b) = above_deriv_v(i,b) * activation_deriv_v(i,b);
      }
    });
  return activated_above_deriv;
}



/**
 * @brief Main program entry point.
 *
 * Initializes the application, generates random matrices, and benchmarks the computation of thin matrix outer products.
 *
 * @param argc Number of command line arguments.
 * @param argv Array of command line argument strings.
 * @return Program exit status.
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
int main(int argc, char** argv){
  initialize(argc,argv);
  std::mt19937 rng(1234);
  
  std::vector<int> data_sizes = { 1, 30, 60, 120, 240, 480, 960, 1920 };
  std::vector<int> batch_sizes = {1, 8, 16, 32, 64, 128, 256, 512, 1024, 2048};

  for(auto size0 : data_sizes){
    for(auto batch_size : batch_sizes){ 

      Matrix<float> a(size0, batch_size);
      Matrix<float> b(size0, batch_size);
      random(a,rng);
      random(b,rng);
    
      double mu, sigma;

      Matrix<float> c;
      profileStart();
      benchmark(mu, sigma, 100, 1, [&]{
	c = computeThinMatOuterProd_v2(a,b);
      }, []{});
      profileStop();

      Matrix<float> ctest = computeThinMatOuterProdBase(a,b);
      assert(abs_near(c,ctest,1e-3f,true));
	
	
      std::cout << "size0:" << size0 << "\tbatch: " << batch_size << "\tresult: " << mu/1e-6 << "us " << sigma/1e-6 << "us" << std::endl;
    }      
  }
  return 0;
}

