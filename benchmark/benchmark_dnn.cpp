#include<HPCortex.hpp>
#include<Testing.hpp>

/**
 * @brief Main entry point of the program.
 *
 * Initializes the application, sets up a random number generator, and defines
 * neural network parameters. It then benchmarks the computation time of the
 * neural network layer's value and derivative calculations.
 *
 * @param argc Number of command line arguments.
 * @param argv Array of command line argument strings.
 * @return Exit status of the program.
 
 
 * @brief Initializes the application with command line arguments.
 *
 * Processes the command line arguments and performs any necessary setup.
 *
 * @param argc Number of command line arguments.
 * @param argv Array of command line argument strings.
  
 * @brief Benchmarks the execution time of a given function.
 *
 * Measures the average and standard deviation of the execution time of the
 * provided function over multiple iterations.
 *
 * @param mu Reference to store the measured average execution time.
 * @param sigma Reference to store the measured standard deviation of execution time.
 * @param numIterations Number of times to execute the function for measurement.
 * @param numWarmupIterations Number of warm-up iterations before measurement.
 * @param func Function to be executed and measured.
 * @param setup Optional setup function to be executed before each iteration.
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
int main(int argc, char** argv){
  initialize(argc,argv);
  std::mt19937 rng(1234);
  
  int data_size = 1000;
  int batch_size = 32;
  
  Matrix<float> weight(data_size,data_size,0.);
  Vector<float> bias(data_size,1.);
  auto m = dnn_layer(input_layer<float>(), weight, bias, ReLU<float>());
  
  Matrix<float> data(data_size,batch_size,0.);
  Matrix<float> got;
  
  double mu, sigma;

  benchmark(mu, sigma, 300, 1, [&]{
    got = m.value(data);
  }, []{});

  std::cout << "value: " << mu/1e-6 << "us " << sigma/1e-6 << "us" << std::endl;

  Matrix<float> above;
  Vector<float> deriv(m.nparams());

  benchmark(mu, sigma, 300, 1,
	    [&]{
	      m.deriv(deriv,0,std::move(above));
	    },
	    [&]{
	      above = Matrix<float>(data_size, batch_size, 0.);
	      m.value(data);
	    }  );

  std::cout << "deriv: " << mu/1e-6 << "us " << sigma/1e-6 << "us" << std::endl;
  
  return 0;
}
