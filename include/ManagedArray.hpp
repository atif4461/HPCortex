#pragma once
#include<MemoryManager.hpp>
#include<Accelerator.hpp>

//An array type whose data movement is controlled by the MemoryManager
//Note, this is not UVM!
template<typename FloatType>
class ManagedArray{
  MemoryManager::HandleIterator handle;
  size_t _size;
 
public:   
  
  ManagedArray(): _size(0){}
/**
 * @brief Constructor for managed array with dynamic memory allocation
 * @param size Number of elements in the array
 * @param alloc_pool Memory pool used for allocation
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
  ManagedArray(size_t size, MemoryManager::Pool alloc_pool = MemoryManager::Pool::DevicePool): _size(size)
  {
    if(size > 0) handle = MemoryManager::globalPool().allocate(size * sizeof(FloatType), alloc_pool);
  }
/**
 * @brief Constructor with initialization value
 * @param size Number of elements in the array
 * @param init Initial value for all elements
 * @param alloc_pool Memory pool used for allocation
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
  ManagedArray(size_t size, FloatType init, MemoryManager::Pool alloc_pool = MemoryManager::Pool::DevicePool): ManagedArray(size, alloc_pool){
    if(size == 0) return;    
    fill(init, alloc_pool);
  }
/**
 * @brief Constructor initializing array with data from vector
 * @param init Vector containing initial values
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
  ManagedArray(const std::vector<FloatType> &init): ManagedArray(init.size(), MemoryManager::Pool::HostPool){
    if(init.size() == 0) return;
    autoView(vv,(*this),HostWrite);
    memcpy(vv.data(), init.data(), init.size()*sizeof(FloatType));
  }  
  
  ManagedArray(ManagedArray &&r): handle(r.handle), _size(r._size){
    r._size = 0;
  }
  ManagedArray(const ManagedArray &r): _size(0){
    *this = r;
  }

/**
 * Assignmentoperator for managed array move semantics 
 * transfers ownership of dynamically allocated memory 
 * from source object to target object * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
  ManagedArray & operator=(ManagedArray &&r){
    if(_size)
      MemoryManager::globalPool().free(handle);
    _size = r._size;
    handle = r.handle;
    r._size = 0;
    return *this;
  }

/**
 * Assignment operator for deep copying of managed array contents.
 * Allocates new memory and transfers data from source array,
 * preferring device allocation when possible to minimize data movement.
 *
 * @param r Source array to copy from
 * @return Reference to this object after assignment
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
  ManagedArray & operator=(const ManagedArray &r){
    if(_size)
      MemoryManager::globalPool().free(handle);
    
    _size = r._size;
    if(_size > 0){
      //We allocate preferentially on the device, but seek to avoid data movement if the device copy is stale      
      if(r.handle->device_in_sync){
	handle = MemoryManager::globalPool().allocate(_size * sizeof(FloatType), MemoryManager::Pool::DevicePool);
	autoView(tv, (*this), DeviceWrite);
	autoView(rv, r, DeviceRead);
	accelerator_for(i, _size, {
	    tv[i] = rv[i];
	  });
      }else{
	handle = MemoryManager::globalPool().allocate(_size * sizeof(FloatType), MemoryManager::Pool::HostPool);
	autoView(tv, (*this), HostWrite);
	autoView(rv, r, HostRead);
	
	memcpy(tv.data(), rv.data(), _size*sizeof(FloatType));
      }
    }
    return *this;
  }
  
  
  inline size_t size() const{ return _size; }
  
  class View{
    FloatType *v;
    size_t _size;
    MemoryManager::HandleIterator handle;
  public:
    accelerator_inline size_t size() const{ return _size; }
    accelerator_inline FloatType* data(){ return v; }
    accelerator_inline FloatType const* data() const{ return v; }

    accelerator_inline FloatType & operator[](const size_t i){ return v[i]; }
    accelerator_inline FloatType operator[](const size_t i) const{ return v[i]; }

/**
 * @brief Constructor for creating a view with specified mode and memory handle
 * @param mode The viewing mode for the data
 * @param handle Iterator referencing the memory location
 * @param _size Size of the data to be viewed
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
    inline View(ViewMode mode, MemoryManager::HandleIterator handle, size_t _size):
      _size(_size), handle(handle), v(_size == 0 ? nullptr : (FloatType*)MemoryManager::globalPool().openView(mode,handle)) {
      if(_size == 0) throw std::runtime_error("Attempting to open a view on a zero-size array");
    }

    inline View(ViewMode mode, const ManagedArray &parent): View(mode, parent.handle, parent._size){}
    
    inline void free(){
      if(_size) MemoryManager::globalPool().closeView(handle);
    }
  };

/**
 * Returns a view object representing the current instance with specified viewing mode.
 *
 * @param mode Viewing mode for the returned view object
 * @return A view object associated with this instance and the given mode
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
  inline View view(ViewMode mode) const{
    assert(_size>0);
    return View(mode, *this);
  }
  
/**
 * Destructor releases allocated memory back to global pool.
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
  inline ~ManagedArray(){
    if(_size)
      MemoryManager::globalPool().free(handle);
  }

/**
 * Initializes all elements of the object with a specified initial value.
 *
 * @param init Initial value to be assigned to all elements.
 * @param assign_pool Memory pool where assignment operation will be performed, default is DevicePool.
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
  void fill(FloatType init, MemoryManager::Pool assign_pool = MemoryManager::Pool::DevicePool){
    if(assign_pool == MemoryManager::Pool::DevicePool){
      autoView(hv, (*this), DeviceWrite);
      {
	accelerator_for(i, _size, {
	    hv[i] = init;
	  });
      }
    }else{
      autoView(hv, (*this), HostWrite);
      thread_for(i, _size, {
	  hv[i] = init;
	});
    }
  }

  inline void lock() const{ MemoryManager::globalPool().lock(handle); }
  inline void unlock() const{ MemoryManager::globalPool().unlock(handle); }
  
};
