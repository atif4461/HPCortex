#pragma once

struct StorageTag{};

//A structure to store instances based on input rvalue references
/**
 * @brief Represents a leaf node storing a single value of type T.
 * @tparam T Type of the stored value.
 * This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
template<typename T>
struct LeafStore{
  T v;
  typedef StorageTag tag;
  typedef T type;
  
  LeafStore(T && v): v(std::move(v)){
  }
  LeafStore(const LeafStore &r) = delete;
  LeafStore(LeafStore &&r): v(std::move(r.v)){}
  
};
//A structure to store instance references based on input lvalue references
/**
 * @brief Reference to a leaf node value
 * @tparam T Type of the referenced value
 
struct LeafRef{
     * @var v Reference to the leaf node value
   
  T &v;
     * @typedef tag Tag indicating storage type
   
  typedef StorageTag tag;
     * @typedef type Type of the referenced value
   
  typedef T type;

     * @brief Constructor initializing the reference
   * @param v Value to be referenced
   
  LeafRef(T &v): v(v){
  }

     * @brief Copy constructor deleted to prevent copying
   
  LeafRef(const LeafRef &r) = delete;

     * @brief Move constructor transferring ownership
   * @param r Reference to transfer ownership from
   
  LeafRef(LeafRef &&r): v(r.v){}
}* This comment was generated by meta-llama/Llama-3.3-70B-Instruct:None at temperature 0.2.
*/ 
template<typename T>
struct LeafRef{
  T &v;
  typedef StorageTag tag;
  typedef T type;
  
  LeafRef(T &v): v(v){
  }
  LeafRef(const LeafRef &r) = delete;
  LeafRef(LeafRef &&r): v(r.v){}

};

//Deduce the appropriate storage type given a reference type
template<typename T>
struct deduceStorage{};

template<typename T>
struct deduceStorage<T&>{
  typedef LeafRef<T> type;
};

template<typename T>
struct deduceStorage<T&&>{
  typedef LeafStore<T> type;
};

#define DDST(a) typename deduceStorage<decltype(a)>::type
#define ISSTORAGE(a) std::is_same<typename std::decay<a>::type::tag,StorageTag>::value
